## 单词拆分

[https://leetcode-cn.com/problems/word-break/](https://leetcode-cn.com/problems/word-break/)






给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。


```
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```





### 代码

暴力破解

>会超时

最简单的实现方法是用递归和回溯。为了找到解，我们可以检查字典单词中每一个单词的可能前缀，如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 true 。



```js
/**
 * @param {string} s
 * @param {string[]} wordDict
 * @return {boolean}
 */
var wordBreak = function (s, wordDict) {
  return word_Break(s, wordDict, 0);
};

function word_Break(s, wordDict, start) {
  if (start === s.length) {
    return true;
  }

  for (let end = start + 1; end <= s.length; end++) {
    if (
      wordDict.indexOf(s.substring(start, end)) > -1 &&
      word_Break(s, wordDict, end)
    ) {
      return true;
    }
  }

  return false;
}
```

---









### 测试



```js
let s = "catsandog",
  wordDict = ["cats", "dog", "sand", "and", "cat"];
const res = wordBreak(s, wordDict);
console.log("res", res);
```







----


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/word-break
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。









